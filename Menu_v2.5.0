////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
//																					  //
//               Kaitlin Sullivan HiPlex Plugin Script - May 2019					  //
//   				for analysis of in situ hybridization data						  //
//																					  //
//			To Install: copy and paste code into the StartupMacros.txt 				  //
//						Plugins -> Macros -> Startup Macros							  //
//																					  //
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////




/////////////////////////////////HELPER FUNCTIONS///////////////////////////////////////

/////////////////////////////////General Functions//////////////////////////////////////

//NUMROUND
//returns the number of imaging rounds present in data
function numRound(dir) {
	fileList = getFileList(dir);
	rnd = 0;
	for (i = 0; i < fileList.length; i++) {
		cur = substring(fileList[i], 1, 2);
		if(!isNaN(cur)){
			if (rnd < cur) {
				rnd = cur;
			}	
		}
	}
	if(rnd == 0){
		exit("Files in directory are improperly named or directory is empty. Ensure files named according to convention: RX_###_genename.");
	}
	else {
		rnd = parseInt(rnd);
		return rnd;
	}
}


//AUTOOPEN
//automatically opens files that start with a specified string
function autoOpen (dir, prefix){
	fileList=getFileList(dir);
	i=0;
	found = false;
	while(found != true){
		if (i >= fileList.length){
			exit("No files found. Check naming convention.");
		}
		else if (startsWith(fileList[i], prefix)&&(!endsWith(fileList[i], ".txt"))) {
			open(dir+fileList[i]);
			found = true;
		}
		i++;
	}
}

//CHANNELS
//returns channels in first round as an array (useful for 3plex FISH)
function channels(dir) {
	fileList=getFileList(dir);

	//instantiate array 
	rc = newArray(1);
	for(i = 0; i<fileList.length; i++){
		//select only files beginning with R1_
		if(substring(fileList[i], 0, 3)=="R1_"){
			sub = substring(fileList[i], 3, 6);
			//exclude any DAPI signals
			if(rc[0] == 0 && sub != 405){
				rc[0] = sub;
			}
			else if(sub != 405){
				rc = Array.concat(rc, newArray(sub));
			}
		}
	}
	return rc;	
}

/////////////////////////////////Registration Functions//////////////////////////////////////
 
//TRANSLATE
//translates the image via input x,y coordinates
function translate(x, y) {
      run("Select All");
      run("Cut");
      makeRectangle(x, y, getWidth(), getHeight());
      run("Paste");
      run("Select None");
}

//SLICE
//makes a slice through the z axis via a diagonal line in x,y
function slice(img, name){
	selectImage(img);
	makeLine(0, 0, getWidth(), getHeight());
	run("Reslice [/]...", "output=1 slice_count=1");
	rename(name);
}

//SIZEUP
//Check for size of images across rounds
function sizeUp(dir) { 
	rnd = numRound(dir);
	fileList = getFileList(dir);
	widths = newArray(rnd);
	heights = newArray(rnd);
	same = true;
	
	//open DAPI rounds and save the heights and widths
	for (i = 1; i <= rnd; i++) {
		nm = "R" + i + "_405";
		print("Opening image: " + nm + "...");
		autoOpen(dir, nm);
		
		widths[i-1] = getWidth();
		heights[i-1] = getHeight();

		//check to see if width and height are the same across rounds
		if (i>1) {
			if ((widths[i-1] != widths[i-2]) |(heights[i-1] != heights[i-2])) {
			same = false;
			}
		}
		close();
	}

	if(!same){
	//sort the arrays 
	widths = Array.sort(widths);
	heights = Array.sort(heights);
	
	//return values for cropping
	c = newArray(widths[0], heights[0]);
	return c;
	}
	else {
		c = newArray(0);
		return c;
	}
}

//CROP
//crops an image
function crop(width, height){
	makeRectangle(0, 0, width, height);
	run("Crop");
}

//MAKEWINDOW
//takes an image and creates a window with width and height as a power of 2 for FFT
function makeWindow(img, name, z){
	
	selectImage(img);
	h = getHeight();
	w = getWidth();
	pwr= 4;
	size = false;
	if(h>w){
		side = w;
	}
	if(w>h){
		side = h;
	}

	while(!size){
		if(pow(2, pwr)>side){
			pwr=pow(2, (pwr-1));
			size=true;
		}
		else{
			pwr++;
		}	
	}

	if(z == 0){
		x = ((w/2)-(pwr/2));
		y = ((h/2)-(pwr/2));
	}

	else{
		x = ((w/z)-(pwr/2));
		y = ((h/z)-(pwr/2));
	}

	makeRectangle(x, y, pwr, pwr);
	run("Copy");
	newImage(name, "8-bit black", pwr, pwr, 1);
	run("Paste");
	run("Select None");
}

//BATCHSPLIT
//batch open and merge files across rounds (hiplex only)
function batchSplit(newDir, rnd, nms) { 
	
	setBatchMode(true);
	print("Splitting and saving channels from Round " + rnd + "...");
	run("Split Channels");
	ch = newArray("C1", "C2", "C3", "C4", "C5");
	
	if(isOpen("Composite")){
	close("Composite");
	}
	
	//autoopen and save names
	for (i = 0; i < ch.length; i++) {
		//substring name of split composite
		convention = getTitle();
		title = substring(convention, 2, lengthOf(convention));
		id = ch[i] + title;
		selectWindow(id);
		path = newDir + nms[i];
		print(nms[i]);
		saveAs("Tiff", path);
		close(nms[i]);
		print("Saved: " + nms[i]);
	}
	
	setBatchMode(false);
}

//BATCHMERGE
//combine images to be maxproj/cropped (hiplex only)
function batchMerge(dir, rnd) { 
	print("Opening and merging channels from Round "+ rnd +"...");
	setBatchMode("hide");
//save number of channels to be used to merge
	chan = channels(dir);
	mer = newArray(chan.length + 1);

//autoopen dapi image if not present
	if(nImages == 0){
		pref = "R" + rnd + "_405";
		autoOpen(dir, pref);
	}
	mer[0] = getTitle();
	print(mer[0]);
	
	//autoopen and save names
	for (i = 0; i < chan.length; i++) {
		pref = "R" + rnd + "_" + chan[i];
		autoOpen(dir, pref);
		mer[i+1] = getTitle(); 
		print(mer[i+1]);
	}
	//merge channels
	run("Merge Channels...", "c1=" + mer[4] + " c2=" + mer[2]+ " c3=" + mer[0] + " c5=" + mer[1] + " c7=" + mer[3] + " create");
	setBatchMode(false);
	//sort the array of names to match Fiji's channel ordering convention
	sorted = newArray(mer[4], mer[2], mer[0], mer[1], mer[3]);
	
	//return array with names
	return sorted;
}

//DAPIMERGE
//open and merge/overlay DAPI across rounds for rigid and elastic registration
function dapiMerge(dir, nl){	
	//instantiate an array to include names of dapi images
	rnd = numRound(dir);
	nms = newArray(rnd);
	setBatchMode("hide");
	
	//open images
	for (i = 1; i <= rnd; i++) {
		if(nl)
			pref = "R" + i + "_405_DAPI.tif_registered.tif_NL.tif";
		else 
			pref = "R" + i + "_405_DAPI.tif";
		autoOpen(dir,pref);
		nms[i-1] = getTitle();
	}
	//overlay if more than 7 channels
	if (nImages>7) {
		for (i = 1; i < rnd; i++) {
			selectImage(nms[0]);
			run("Add Image...", "image="+nms[i]+" x=0 y=0 opacity=50 zero");
		}
	}
	//merge if 7 or less channels
	else{
		str = "";
		for (i = 1; i <= rnd; i++) {
			//create string of channels to pass through merge
			str = str + "c" + i + "=" + nms[i-1] + " ";
		}
		run("Merge Channels...", str + " create ignore");
	}
	setBatchMode("exit and display");
}

//FINDMAX
//findMax written by Mark Cembrowski
function findMax() {
	// identify number of columns in Results table
	nCol=0;
	isCol=true;
	while(!isNaN(isCol)){
		curCol="X"+nCol;
		isCol=getResult(curCol,0); // returns Nan if doesn't exist
		nCol++;	
	}
	nCol=nCol-1; // subtract one for last added value

	// iterate over rows and columns of Results table to find row and column that have
	// highest values. this reflects translation with highest correlation.
	rMax=0; // refers to exact row value (i.e., inclusive of 0)
	cMax=0; // refers to exact col value (i.e., "X_cMax")
	curMax=0;
	for (ii=0;ii<nResults;ii++){
		for (jj=0;jj<nCol;jj++){
			curRow=ii;
			curCol="X"+jj;
			curVal=getResult(curCol,curRow);
			if(curVal>curMax){
				curMax=curVal;
				rMax=ii;
				cMax=jj;
			}
		}
	}
	// the amount to translate by can be obtained for the indices of the row and column
	// with maximum correlation. the deviation of these points from the centre point
	// represent the amount to translate.
	nRow=nCol;	// note images are square and thus ncol=nrow
	xTrans=(cMax-nCol/2);
	yTrans=(rMax-nRow/2);

	xyTrans = newArray(xTrans, yTrans);
	return xyTrans;
}


/////////////////////////////////Quantification Functions//////////////////////////////////////

//HISTPERCENTILE
//Select a threshold via finding the tail end of a normalized cumulative histogram
function histPercentile(img, percent){
	//ensure correct window is active image
	selectWindow(img);
	
	//get the histogram of the image
	getHistogram(values, counts, 256);
	nBins = 256;

	//get the cumulative histogram by adding up consecutive bin values
	cHist = newArray(nBins);
	cHist[0] = counts[0];
	for (i = 1; i < nBins; i++) {
		cHist[i] = counts[i] + cHist[i-1];
	}

	//normalize by dividing each bin value by the final bin value of the cumulative histogram
	ncHist = newArray(nBins);
	for (i = 0; i < nBins; i++) {
		ncHist[i] = cHist[i]/cHist[nBins-1];
	}

	//find the 99th percentile
	bin = 0;
	thresh = 0;

	//99th percentile is saved as thresh -> the value to be returned and set as the threshold for the image
	while (ncHist[bin] <= percent) {
		thresh = ncHist[bin];
		bin++;
	}
	
	//return the bin number with 99th percentile
	return(bin);
}

//QUANT
//quantifies image (by image ID) either automatically (c>=1) or individually (c = 0)
function quant(img, c, thresh, upper){
	
	//convert to 8bit
	run("8-bit");

	//save the directories for registered and unregistered images
	regDir = getDirectory("image");
	rdL = lengthOf(regDir);
	dir = substring(regDir, 0, rdL-10);

	//750 channels - require smoothing due to poor signal-to-noise
	if (substring(img, 3, 6) == "750") {
		run("Smooth");
	}
	
	//SINGLE CHANNEL
	if(c == 0){
		//threshold and wait for user response
		run("Threshold...");
		waitForUser("Adjust the threshold slider & APPLY. Then, press OK in this window."); 
	}
	
	//AUTOTHRESHOLDING
	else {
		if(c >= 1){	
			
			//threshold the image
			setThreshold(thresh, upper);
			setOption("BlackBackground", true);
			
		}
	}
	run("Convert to Mask", "method=Default background=Dark black");
	
	
	//save a binarized image in OVERLAY folder for final composite image
	ovDir = regDir + "overlay" + File.separator;
	maskFile = ovDir + name;
	saveAs("Tiff", maskFile);

	//quantify the expression
	roiManager("measure");
	close("Threshold");
	//run("Close All");
}

//SAVEFILES
//saves an image, tab, and log file for each channel to be quantified
function saveFiles(img, ovDir, imgDir, tabDir, funct){
		
	if (isNaN(ovDir)) {
		open(ovDir + img);
		// Save results table
		resultsFile = tabDir + name + "_" + funct + ".csv";
		saveAs("Results",resultsFile);
		run("Clear Results");
	}

	if(nSlices==1){
		// Prep images for saving
		roiManager("Show All");
		roiManager("Show All with labels");
		run("Flatten");
	
		close("\\Others");
		
		toOpen = dir + img; // reopen original ISH window
		open(toOpen);
		run("Images to Stack");
		stackFile = imgDir + img + "_mask.tif";
		saveAs("Tiff",stackFile);
	}
	else{
		roiManager("Show All");
		roiManager("Show All with labels");
		stackFile = imgDir + img + "_mask.tif";
		saveAs("Tiff", stackFile);
	}	
}



/////////////////////////////////////////////////////////////////////////////////////////////
//																						   //
//									HIPLEX DROPDOWN MENU								   //
//																						   //
/////////////////////////////////////////////////////////////////////////////////////////////


//menu icon + dropdown creation
var hmCmds = newMenu("HiPlex Menu Tool", 
	newArray("Automated Run...","-","Registration", "Segmentation", "Quantification", "-", "HiPlex Overlay", "Single Channel Quantification", "Filter Blood Vessels"));
macro "HiPlex Menu Tool - CfffD00D01D02D03D0dD0eD0fD10D11D12D16D17D18D19D1bD1dD1eD1fD20D21D24D25D26D28D2bD2eD2fD30D31D34D38D39D3cD3eD3fD40D41D43D45D47D48D49D4fD50D51D53D57D5aD5fD60D63D66D67D69D6cD6dD6fD70D72D73D76D78D79D7cD7fD80D83D86D87D89D8aD8fD90D91D93D95D97D99D9aD9eD9fDa0Da1Da3Da4Da7Da9DacDaeDafDb0Db1Db4Db7DbaDbcDbfDc0Dc1Dc4Dc5Dc8DcaDcdDcfDd0Dd1Dd2Dd5Dd6Dd8DdbDdfDe0De1De2De3De6De7De8De9DeeDefDf0Df1Df2Df3Df4DfcDfdDfeDffCe12D27D35D36D37D44D54D64D65D74D75D84D85D94Db5Db6Dc6Dc7Dd7C000D05D06D07D08D09D0aD0bD0cD13D14D1cD23D2cD2dD32D33D3dD42D4dD52D5eD61D62D6eD71D7eD81D82D88D8dD8eD92D98D9dDa2Da8DadDb2Db3Db9DbdDbeDc3Dc9DceDd3Dd4Dd9DdaDddDdeDe4De5DeaDebDecDedDf5Df6Df7Df8Df9DfaC36bD1aD29D2aD3aD3bD4bD4cD5cCfe1D59D6aD7aD7dD8cD9cDabDbbDcbDccDdc"{

//BUILT-IN FIJI MACROS		
		builtin = newArray("Open...", "Merge Channels...", "Channels Tool...");
		cmd = getArgument();
		if (cmd!="-"){
			if (cmd == builtin[0] || cmd == builtin[1] || cmd == builtin[2]) {
				doCommand(cmd);
			}
			else {
//AUTO RUN			
				if(cmd != "Automated Run..."){
					auto = false;
				}	
				if(cmd == "Automated Run..."){
					auto = true;
					cmd = "Registration";
				}
				
				
/////////////////////////////////////////REGISTRATION///////////////////////////////////////////////////								
// SET UP:
				if (cmd == "Registration") {
					//throw errors for incorrect naming
					if(nImages == 0)
						exit("No images open. Please open a DAPI image for segmentation.");
					if(nImages > 1)
						exit("Please open only the first round of DAPI imaging and close any other image windows.");			

					//save directory and number of rounds present
					dir = getDirectory("image");
					rnd = numRound(dir);
					chan = channels(dir);
					nm1 = getTitle();
		
// MAX or 3D:
			//assume a single plane image
					maxp = "sp";
			//if the image is a stack then GUI pop up for maxprojection
					if(nSlices > 1){
						maxDir = dir + "max" + File.separator;
						File.makeDirectory(maxDir);
						maxp = "max";

						for (i = 1; i <= rnd; i++) {
						//batch mode open images and merge them
							nms = batchMerge(dir, i);
							print("Creating Maximum Intensity Projection for Round" + i);
						//make max projection
							run("Z Project...", "projection=[Max Intensity]");
						//batch mode split channels and re-save cropped versions
							batchSplit(maxDir, i, nms);
						}
							//make this the main directory for future registration
						dir = maxDir;
					}
						
					//throws error if only one round (numRound also throws error if no rounds)
					if (rnd == 1) 
						exit("Registration requires 2 or more rounds of imaging. \n There is only one round of imaging present in provided directory.");
					if(!endsWith(nm1, "DAPI.tif"))
						exit("Incorrectly titled image or wrong image kind. \n Please open DAPI round 1 image: R1_405_DAPI.tif");

//CROPPING:
					print("Measuring image sizes across rounds...");
					cVal = sizeUp(dir);
					//all images must be the same width
					if (cVal.length != 0) {
						//create a directory to save cropped images
						cropDir = dir + "crop" + File.separator;
						File.makeDirectory(cropDir);
						
						//pop up GUI with option to autocrop or exit and manually crop
						if(!auto){
							Dialog.create("Error: Images are of different sizes! \n Would you like the macro to auto-crop each image by X = " + cVal[0] + " pixels and Y = " + cVal[1] + " pixels, \n or would you like to manually crop?");
							Dialog.addChoice("Choice: ", newArray("Auto-crop", "Manual crop"), "Auto-crop");

							Dialog.show();
							cChoice = Dialog.getChoice();
						}
						else 
							cChoice = "Auto-crop";
						
						//create a new cropping directory
						if(maxp == "max"){
								cropDir = maxDir + "crop" + File.separator;
								File.makeDirectory(cropDir);
						}

						
//AUTOCROP:
						if(cChoice == "Auto-crop"){
						print(rnd);
							//for each round, batch merge, create a rectangle, then split and save
							for (i = 1; i <= rnd; i++) {
								//batch mode open images and merge them
								nms = batchMerge(dir, i);

								makeRectangle(0, 0, cVal[0], cVal[1]);
								
								print("Cropping images for Round " + i + "...");
								run("Crop");
								
								//batch mode split channels and re-save cropped versions
								batchSplit(cropDir, rnd, nms);
							}
						}

//MANUAL CROP:
						if (cChoice == "Manual crop") {
							//for each round, batch merge, create a rectangle, then split and save
							for (i = 1; i <= rnd; i++) {
								//batch mode open images and merge them
								nms = batchMerge(dir, i);
								//make a box and wait for the user to drag it to the desired region
								makeRectangle(0, 0, cVal[0], cVal[1]);
								waitForUser("Manual Crop", "Drag the yellow box to the appropriate ROI for cropping and then press OK");
								
								//batch mode split channels and re-save cropped versions
								print("Cropping images for Round " + i + "...");
								run("Crop");
								batchSplit(cropDir, rnd, nms);
							}
						}
					//make the croping directory the new, main directory
					dir = cropDir;
					}

//REGISTRATION SET UP:
					//make a directory for registered + analyzed images
					regDir = dir + "regImages" + File.separator;
					File.makeDirectory(regDir)
					
				//open round 1
					autoOpen(dir, "R1_405");
					img1 = getImageID();
					nm1 = getTitle();
					//make 2^n x 2^n registration window
					makeWindow(img1, "Round1", 0);
					r1=getImageID();
				//counter for number of rounds registered
					cnt = 2;
					print("Registering in X,Y...");

				//eg array size 4 for 3 rounds
					zChange = newArray((rnd-1)*2);
					
//REGISTRATION LOOP:
					while(cnt <= rnd){
						rndNum = "R" + cnt + "_405";
						autoOpen(dir, rndNum);
						img2 = getImageID();
						nm2 = getTitle();
						makeWindow(img2, "Round2", 0);
						r2=getImageID();
						
						// cross-correlate images
						run("FD Math...", "image1=Round1 operation=Correlate image2=Round2 result=Result do");
						selectImage(r2);
						close();
						
						// write the new Image to a Results table.
						run("Image to Results");
						selectWindow("Result");
						close();

//SEARCH HIGHEST PIXEL VALUE:
						// identify number of columns in Results table. this should be rewritten as a helper
						// function in later code.
						nCol=0;
						isCol=true;
						while(!isNaN(isCol)){
							curCol="X"+nCol;
							isCol=getResult(curCol,0); // returns Nan if doesn't exist
							nCol++;	
						}
						nCol=nCol-1; // subtract one for last added value
						// iterate over rows and columns of Results table to find row and column that have
						// highest values. this reflects translation with highest correlation.
						rMax=0; // refers to exact row value (i.e., inclusive of 0)
						cMax=0; // refers to exact col value (i.e., "X_cMax")
						curMax=0;
						for (ii=0;ii<nResults;ii++){
							for (jj=0;jj<nCol;jj++){
								curRow=ii;
								curCol="X"+jj;
								curVal=getResult(curCol,curRow);
								if(curVal>curMax){
									curMax=curVal;
									rMax=ii;
									cMax=jj;
								}
							}
						}

//TRANSLATION:
						// the amount to translate by can be obtained for the indices of the row and column
						// with maximum correlation. the deviation of these points from the centre point
						// represent the amount to translate.
						nRow=nCol;	// note images are square and thus ncol=nrow
						xTrans=(cMax-nCol/2);
						yTrans=(rMax-nRow/2);
						run("Clear Results");
	
						// translate DAPI according to xTrans and yTrans
						selectImage(img2);
						if (maxp != "3D") {
							print("Registering in X,Y...");
							translate(xTrans, yTrans);
						}



					//save files
						regImg = regDir + nm2 + "_registered.tif";
						saveAs("Tiff",regImg);

//TRANSLATE CHANNELS:
						//translate in situ signals for subsequent rounds
						for (i = 0; i < 4; i++) {
							//open
							pref = chan[i];
							file = "R" + cnt + "_" + pref;
							autoOpen(dir, file);
							nm = getTitle();
							//translate
							translate(xTrans, yTrans);
							regImg = regDir + nm + "_registered.tif";
							saveAs("Tiff",regImg);
							close();
						}
						run("Clear Results");
						
			//addition for autothreshold: include a file that holds the translation coords					
						tf = regDir + "translate" + cnt + ".txt";
						f = File.open(tf);
						print(f, xTrans + " \n" + yTrans);
						File.close(f);
						cnt++;
					}
					run("Close All");
					
//SAVE R1:
				for (i = 0; i < 5; i++) {
					if(i==0)
						pref = 405;
					else
						pref = chan[i-1];
	
					file = "R1_" + pref;
					autoOpen(dir, file);
					nm = getTitle();
				
					regImg = regDir + nm + "_registered.tif";
					saveAs("Tiff",regImg);
					close();
				}
				//close remaining windows
				run("Close All");

//NONLINEAR:
// (Rennie): Allow user to check rigid registration of DAPI images, and to run non-linear registration if they are not satisfied 
//(Code augemented by kaitlin sullivan for brevity)

				//merge rigid registration images
				dapiMerge(regDir, false);

				//get user input to perform elastic registration
				if(!auto){
					Dialog.create("Rigid Registration");
					Dialog.addMessage("Would you like to apply non-linear registration to the images? \n (Note: this rigid registration DAPI overlay will be saved at regImages/composite)");
					choices = newArray("Yes", "No"); 
					Dialog.addChoice("Select one: ", choices, choices[0]);
					Dialog.show();
					choice = Dialog.getChoice();
				}
				else{
					choice = "Yes";
				}
				
				//save dapi overlay from linear reg
				compDir = regDir+"composite"+File.separator;
				File.makeDirectory(compDir);
				saveAs("Tiff", compDir + "rigid_composite.tif");	
				run("Close All");	

// NON-LINEAR REG: Users chooses to proceed with non-linear registration
				if (choice == "Yes"){
					//create new folder		
					nlDir = regDir + "nonLinearReg" + File.separator;
					File.makeDirectory(nlDir);

					//Copy R1 imgs to nonLinearReg file folder
					print("Copying Round 1 channels before proceeding with non-linear registration...");
					regFiles = getFileList(regDir);
					for (n=0; n < regFiles.length; n++){
						if (startsWith(regFiles[n],"R1")){
							File.copy(regDir+regFiles[n], nlDir+regFiles[n]+"_NL.tif");
						}
					}

// Register all subsequent rounds with round 1, saving the transformation from RX to R1 (for X=2,3...)
					print("Beginning non-linear registration...");
					//open R1 image
					autoOpen(regDir, "R1_405");
					target=getTitle();
					rnd = numRound(regDir);
					
					for (m = 2; m <= rnd; m++) {
						//open DAPI from each round
						print("Opening DAPI image for Round" +m+ "...");
						source = "R" + m + "_405";
						autoOpen(regDir, source);
						curDAPI = getTitle();
						transf_file = nlDir+curDAPI+"_transf.txt";

						//run nonlinear registration
						print("Now registering R"+ m +" DAPI to R1 DAPI...");
						run("bUnwarpJ","source_image=&curDAPI target_image=&target registration=Mono image_subsample_factor=0 initial_deformation=[Very Coarse] final_deformation=[Super Fine] divergence_weight=0.1 curl_weight=0.1 landmark_weight=0 image_weight=1 consistency_weight=10 stop_threshold=0.01 save_transformations save_direct_transformation=["+transf_file+"]");
						selectWindow("Registered Source Image");
						run("Stack to Images");
						selectWindow("Registered Source Image");
						run("8-bit");
						saveAs("Tiff",nlDir + curDAPI +"_NL.tif");

						//Close all windows but target image (R1 DAPI)
						selectWindow(target);
						close("\\Others");
						
						print("Applying transformation to channel images...");
						//open each channel
						for (k=0; k<4; k++){			
							curChan = "R" + m + "_" + chan[k];
							autoOpen(regDir, curChan);
							channel_image = getTitle();

							//run dapi transform
							call("bunwarpj.bUnwarpJ_.elasticTransformImageMacro", regDir+target, regDir+channel_image,transf_file, nlDir+channel_image+"_NL.tif");
			      			selectWindow(target);
							close("\\Others");
						}
					}
					run("Close All");
					//make composite
					print("Creating final overlay of nonlinearly registered DAPIs.");
					dapiMerge(nlDir, true);

					if(!auto){
						Dialog.create("Elastic Registration Composite");
						Dialog.addMessage("The following composite shows the elastic registration of all DAPI images. \n \n (Note: this image can be found at regImages/composite)");
						Dialog.show();
					}
					
					
					//save image
					selectImage("Composite");
					saveAs("Tiff", compDir+"elastic_composite.tif");
				}
				run("Close All");
				close("Results");
				if(!auto)
					exit("Registration Complete! \n \n To segment cell bodies, open first DAPI image from generated regImages folder and run Segmentation.");	
				else{
					print("Beginning segmentation...");
					autoOpen(nlDir, "R1_405_DAPI.tif");
					cmd = "Segmentation";
				} 
					
			}

/////////////////////////////////////////////////////////////////////////////////////////////
//SEGMENTATION CODE				
				if (cmd == "Segmentation") {

					//throw error if no images open
					if(nImages == 0){
						exit("No images open. \n Please open a DAPI image for segmentation.");
					}

					if(nImages > 1){
						exit("Please open only one DAPI image and close any other image windows.");
					}
//NEW: check for zstack in DAPI signal
					zstack = false;
					if(nSlices >1){
						zstack = true;
					}

					
					// Mark Cembrowski, UBC, 2019
					//run("Set Scale...", "distance in pixels=0 known distance=0 pixel aspect ratio=1 unit of length=pixel");
					
					areaThres=30; 	// area threshold. discard ROIs with pixel areas below this value.
					areaThresLarge=150;  // area threshold. discard ROIs with pixel areas above this value.
					dilationVal=3; 	// dilation amount, in pixels, to use for all kept nuclei.

					dir = getDirectory("image");
					nround = numRound(dir);
					name=getTitle;
					

					//throw error if image is not DAPI
					//if(substring(name, 7, 11)!= "DAPI"){
					//	exit("Incorrect image or incorrectly titled image. \n Please open a DAPI image. (Naming convention: R#_405_DAPI.tif)");
					//}
					
					imgDir = dir + "analyzedImages" + File.separator;
					File.makeDirectory(imgDir);
					tabDir = dir + "analyzedTables" + File.separator;
					File.makeDirectory(tabDir);

//2D-3D REG
					//Gaussian blur
					if(zstack){
						run("Gaussian Blur 3D...", "x=2 y=2 z=2");
					}
					else{ 
						run("Gaussian Blur...", "sigma=2");
					}

//select r1 or 3dreg
print(nround);
					if(nround<=1){
						seg="Round 1 Only";
					}
					if(nround>1){
						Dialog.create("Segmentation Type");
						Dialog.addMessage("Would you like to segment across rounds or on round 1 only? \n (NOTE: segmenting on round 1 only is not recommended as differences in z-stacks across rounds can affect quantification.)");
						Dialog.addChoice("Segmentation Type: ", newArray("Normal Segmentation", "Round 1 Only"));
						Dialog.show();
						
						seg=Dialog.getChoice();
					}

					if(seg=="Normal Segmentation"){
						//threshold the image
						thresh = histPercentile(name, 0.85);
						setThreshold(thresh, 255);
						setOption("BlackBackground", true);
						run("Convert to Mask");
					
						for (i = 2; i <= nround; i++) {
							//open subsequent rounds
							pref = "R" + i + "_405_DAPI.tif";
							autoOpen(dir, pref);
			 				cur = getTitle();
							run("Gaussian Blur...", "sigma=2");
							run("Convert to Mask");
						
							//threshold the image
							thresh = histPercentile(cur, 0.85);
							setThreshold(thresh, 255);
							setOption("BlackBackground", true);
							
							//multiply first two rounds
							if(i==2){
								imageCalculator("Multiply create", name, cur);
								prod = getTitle();
								close("\\Others");
							}
							//subsequent rounds
							if(i>2){
								imageCalculator("Multiply create", prod, cur);
								prod = getTitle();
								close("\\Others");
							}
						}
					}
					
					
					// Binarize image and add segmented nuclei to ROI Manager.
					if(seg=="Round 1 Only"){
						run("8-bit");
						run("Threshold...");
						setThreshold(40, 255);
						waitForUser("adjust top threshold slider, hit Set->ok in THAT window, then hit ok HERE");
						getThreshold(imageThres,thresHi);
						setThreshold(imageThres, thresHi);
						setOption("BlackBackground", true);
						//stack add
						if(zstack){
							run("Convert to Mask", "method=Default background=Dark black");
						}
						else{
							run("Create Mask");
						}
					}
					waitForUser("Draw an ROI with polygon or rectangle tool, then hit OK here.");// added Tim, limit analysis to a specific ROI
					run("Add Selection...");
					run("To ROI Manager");
					run("Remove Overlay");
					//run("Convert to Mask");
					run("Watershed", "stack"); // added Tim June 26 2019, helps with segmentation
					//stack add
					if(zstack){
							run("Convert to Mask", "method=Default background=Dark black");
						}
						else{
							run("Create Mask");
						}
					run("From ROI Manager");
					roiManager("Select", 0);
					if(zstack){
						run("Analyze Particles...", "clear add stack");
					}
					else{
						run("Analyze Particles...", "clear add");
					}

					// Delete small areas; dilate areas that pass threshold.
					run("Clear Results");
					totRois = roiManager("count");
					run("Set Measurements...", "area redirect=None decimal=3");
					for (mm=totRois-1;mm>-0.5;mm--){
						roiManager("Select",mm);
						run("Measure");
						totArea=getResult("Area");
						if(totArea<areaThres){
							roiManager("Delete");
							//roiManager("Update");
						}
						else{
						run("Enlarge...","enlarge=dilationVal");
						roiManager("Update");	
						}
					}

					//save ROIs
					//roiManager("Save", tabDir + "RoiSet.zip");
					finRois = roiManager("count");

					// Set measurement parameters for all dilated ROIs. Measure results.
					// Added Tim June 26, 2019 - Centroid and stack values for localization of cells
					run("Set Measurements...", "area mean min shape centroid stack redirect=None decimal=3");
					roiManager("measure");

					total = "Total number of segmented nuclei: " + finRois;
					print(total);

					//save ROIs
					roiManager("Save", tabDir + "RoiSet.zip");
					finRois = roiManager("count");

					//print updates:
					print("Saving image stack, please wait...");
					//saveFiles(name, 1, imgDir, tabDir, "segmented");

					// Save results
					//resultsFile = tabDir + name +  "_segmented.csv";
					//saveAs("Results",resultsFile);
					//run("Clear Results");


					// Close down all unnecessary windows.
					// Note ROIs are left behind for use by other downstream macros
					run("Close All");
					close("Results");
					close("Threshold");
					if(!auto)
						exit("Segmentation Complete! \n Please keep ROI Manager window open for use in the Quantification Macro. \n To quantify, open the first in situ channel image and run Quantification.");
					else{
						print("Beginning quantification");
						autoOpen(dir, "R1_488");
						cmd = "Quantification";
					}
				}
/////////////////////////////////////////////////////////////////////////////////////////////
//QUANTIFICATION CODE			
				if (cmd == "Quantification" || cmd == "Single Channel Quantification") {

					//throw error if no images or more than one image open
					if(nImages == 0)
						exit("No images open.");
					if(nImages > 1)
						exit("Please open only one in situ image and close any other image windows. \n (Keep ROI Manager open)");
					
					//get directory and title of open image
					dir = getDirectory("image");
					name=getTitle;

					//throw error if not a channel
					if (substring(name, 7, 11)=="DAPI") 
						exit("Channel image required.");
					
 					//create new file directories for the image masks and the quantification tables
					imgDir = dir + "analyzedImages" + File.separator;
					File.makeDirectory(imgDir);
					tabDir = dir + "analyzedTables" + File.separator;
					File.makeDirectory(tabDir);
					ovDir = dir + "overlay" + File.separator;
					File.makeDirectory(ovDir);

					//open segmented ROIs
					run("ROI Manager...");

					roi = tabDir + "RoiSet.zip";
					
					//throw error if no ROIs saved
					if (!File.exists(roi)) 
						exit("Please run segmentation prior to quantification.");
					if(roiManager("count")==0)
						roiManager("Open", roi);
					
					//manual quantification
					if (cmd == "Single Channel Quantification") {
						// Clear results, in case populated from other analyses.
						run("Clear Results");
						quant(name, 0, 0, 0);
						saveFiles(name, ovDir, imgDir, tabDir, "quantification");
						run("Close All");
					}

//PREFILTERING		

					else{
					//save dir and channels
					dir = getDirectory("image");
					chan = channels(dir);
					rnd = numRound(dir);
					
					//close();


					//GUI
					//Dialog.create("Prefiltering");
					//Dialog.addMessage("Would you like to prefilter any noisy images? \n \n (Note: This step only needs to be performed once. Do not prefilter multiple times.)");

					//get file names
					//files = getFileList(dir);
					//channelfiles = newArray(rnd*chan.length);
					//j = 0;
					//for (i = 0; i < files.length; i++) {
						//if((indexOf(files[i], "DAPI")<0) && (endsWith(files[i], ".tif"))){
							//channelfiles[j] = files[i];
							//j++;
						//}
					//}
					//channelfiles = Array.sort(channelfiles);

					//present file names in gui
					//for (i = 0; i < channelfiles.length; i++) {
						//Dialog.addCheckbox(channelfiles[i], false);
					//}
					//Dialog.show();

//save values

					//for (i = 0; i < channelfiles.length; i++) {
						//tf = Dialog.getCheckbox();
						//if(tf == true){
							//new directory
							//open(dir + channelfiles[i]);
							//run("Remove Outliers...", "radius=1 threshold=40 which=Bright");
							//saveAs("Tiff", (dir + channelfiles[i]));
							//close();
						//}
					//}
					
					
					//open(dir + channelfiles[0]);
					
//AUTOQUANT			

					cnt = 0;
					rnd = 1;
					totRnd = numRound(dir);
					numChnl = channels(dir);
					tot = (totRnd*numChnl.length);

//NEW								//choose method of thresholding
			Dialog.create("Select Threshold Method...");
			Dialog.addMessage("Choose a method of thresholding: ");
			cc = newArray("Slider","Histogram Percentile");
			Dialog.addChoice("Method: ", cc, cc[1]);

			Dialog.show();
			opt = Dialog.getChoice();

			//histogram percentile
			if(opt == cc[1]){
				Dialog.create("Select Threshold...");
				Dialog.addMessage("Select a value from 0-100% of the the histogram tail.");
				Dialog.addNumber("Threshold Value: ", 0.998);

				Dialog.show();
				val = Dialog.getNumber();
				//get the optimal thresholding value
				img = getTitle();
				thresh = histPercentile(img, val);
				upper = 255;
			}
			//threshold slider
			if(opt == cc[0]){
				run("Threshold...");
				waitForUser("Adjust the threshold slider & APPLY. Then, press OK in this window.");
				getThreshold(lower, upper);
				thresh = lower;
				
			}

					if(totRnd >1){
						//auto-open all channels
						for (i = 0; i < tot; i++) {

							// Clear results, in case populated from other analyses.
							run("Clear Results");

							quant(name, rnd, thresh, upper);
							saveFiles(name, ovDir, imgDir, tabDir, "quantification");
							run("Close All");
							//again, this assumes that there are 4 channels + DAPI per round
							if (i%4 == 0 && i != 0){
								cnt = 0;
								rnd++;
							}
							//open next image
							if(rnd <= totRnd){
								pref = "R" + rnd + "_" + numChnl[cnt];
								autoOpen(dir, pref);
								name = getTitle();
								cnt++;
							}
						}
					}
		//3PLEX
					if(totRnd == 1){
						for (i = 0; i < numChnl.length; i++) {
							quant(name, 1, thresh, upper);
							saveFiles(name, ovDir, imgDir, tabDir, "quantification");
							run("Close All");
							if(i+1<numChnl.length){
								pref = "R1_" + numChnl[cnt];
								autoOpen(dir, pref);
								name = getTitle();
								cnt++;
							}
						}
					}

					
					run("Close All");
					close("Results");
					close("Threshold");
					}
					if(!auto)
						exit("Quantification Complete \n For a final composite product: utilize HiPlex Overlay or Merge Channels for 3-Plex");
					else{
						print("Beginning overlay creation...");
						autoOpen(ovDir, "R1_488");
						cmd = ("HiPlex Overlay");						
					}
				}
			}

				
/////////////////////////////////////////////////////////////////////////////////////////////
//HIPLEX OVERLAY
				if (cmd == "HiPlex Overlay") {
					//set custom LUTS
					function myLuts(colour) { 
						choices = newArray("Green", "Magenta", "Cyan", "Yellow", "Red", "Blue", "Lavender", "Orange", "Purple", "PaleBlue", "Pink");
						for (i = 0; i < 6; i++) {
							if (colour == choices[i]) {
								run(choices[i]);
							}
						}
						dir = getDirectory("luts");
						for (i = 6; i < 11; i++) {
							if (colour == choices[i]){
								if (colour == choices[i]){
									path = dir + choices[i] + ".lut";
									open(path);
								}
							}
						}
					}
					
					dir = getDirectory("image"); //get filepath for directory of current image
					chan = channels(dir); //get number of channels
					rnd = numRound(dir); //number of rounds

					//filepath for directory conaining quantified tables
					l = lengthOf(dir) - 8;
					 
					tabDir = substring(dir, 0, l) + "analyzedTables" + File.separator;
					//close first channel image
					close();
					
					fluo = newArray(chan.length*rnd); // array containing total ISH fluorescence
					names = newArray(chan.length*rnd); //array containing corresponding image names

					cnt = 0; //channel number
					//open each of the quantified tables and sum up total ISH signal
					for (i = 0; i < rnd; i++) {
						for(j = 0; j < chan.length; j++){
							
							sum = 0; //sum of fluorescence for each channel
							
							pref = chan[j];
							pref = "R" + (i+1) + "_" + pref;
							autoOpen(tabDir, pref);

							//save image name
							names[cnt] = File.name;
							//resTab = tabDir + names[cnt];
							//run("Results... ", "open=" + resTab);

							//add up fluorescence
							for (x = 0; x < nResults; x++) {
								v = getResult("Mean", x);
								sum = sum + v;
							}
							
							fluo[cnt] = sum;

							close(names[cnt]);
							cnt++;
						}
					}
					close("Results");
					
					
					Array.sort(fluo, names);
					Array.reverse(fluo);
					Array.reverse(names);

					
					//pop-up GUI for selecting colours
					
						Dialog.create("HiPlex Overlay: Incomplete Macro");
						Dialog.addMessage("This GUI does not work right now \n Changing any option here won't do anything (but will one day), so just press ok :)");

						colours = newArray("Select a Colour...", "White", "Green", "Magenta", "Cyan", "Yellow", "Red", "Lavender", "Blue", "Orange", "Purple", "PaleBlue", "Pink");

						//adds all options to pop-up window
						for (i = 0; i < names.length; i++) {
							//Dialog.addCheckbox(" ", true);
							//Dialog.addToSameRow();
							l = (lengthOf(names[i]) - 38);
							//Dialog.addString("Channel", (i+1));
							//Dialog.addToSameRow();
							//Dialog.addChoice(substring(names[i], 7, l), colours, colours[i+1]);
							n = "Channel " + (i+1)+ ":";
							Dialog.addChoice(n, names, names[i]);
							Dialog.addToSameRow();
							Dialog.addChoice(" ", colours, colours[i+1]);
						}
						Dialog.addCheckbox("Preview", false);

						//hide every image except for the overlay image
						setBatchMode(true);
						//open all images
						for (i = 0; i < names.length; i++) {
							ovName = dir + substring(names[i], 0, (lengthOf(names[i])-19));
							ovPath = dir + ovName;
							open(ovName);
						}
//display gui
						Dialog.show();
					
//save inputted gene name and colour orders
						newNames = newArray(names.length);
						newColours = newArray(colours.length-1);
						nCnt = 0;
						cCnt = 0;
						for (i = 0; i < (names.length*2); i++) {
							if(((i+2)%2) == 0){
								if(i == 0){
									newNames[nCnt] = Dialog.getChoice();
									nCnt++;
								}
								else{
									newNames[nCnt] = Dialog.getChoice();
									nCnt++;
								}
							}
							else{
							newColours[cCnt] = Dialog.getChoice();
							cCnt++;
							}	
						}

					
					
					//checked preview
						prev = Dialog.getCheckbox();
						while(prev){
							baseImg = dir + substring(newNames[0], 0, (lengthOf(names[0])-19));
							selectWindow(baseImg);
							base = getImageID();
						
						
						//change luts and overlay
							for (i = 0; i < newNames.length; i++) {
								ovName = substring(newNames[i], 0, (lengthOf(names[i])-19));
								selectWindow(ovName);
								myLuts(newColour[i]);
							}
							//show only overlay image
							setBatchMode("show");
							for (i = 1; i < newNames.length; i++) {
								//overlay
								selectImage(base);
								run("Add Image...", "image="+ovName+" x=0 y=0 opacity=100 zero");

							}
						}
						setBatchMode(false);
					
					//open the base image and ensure greyscale
					ovName = dir + substring(names[0], 0, (lengthOf(names[0])-19));
					open(ovName);
					base = getImageID();
					run("Grays");
					
					for (i = 1; i < names.length; i++) {
						//for all subsequent images: open and change lut
						ovName = substring(names[i], 0, (lengthOf(names[i])-19));
						ovPath = dir + ovName;
						open(ovPath);
						myLuts(colours[i]);
						cur = getImageID();
						//overlay
						selectImage(base);
						run("Add Image...", "image="+ovName+" x=0 y=0 opacity=100 zero");
						selectImage(cur);
						close();	
					}
					path = dir + "TESTcomp";
					saveAs("PNG", path);
					if(auto){
						showMessage("Congratulations!!!", "Analysis complete ٩(^ᴗ^)۶");
					}
					//exit("This macro is still incomplete :)");
						
				}
				if(cmd == "Filter Blood Vessels"){
					//gui
					Dialog.create("Area Threshold");
					Dialog.addNumber("Discard all ROIs with an area smaller than: ", 150);
					Dialog.show();

					areaThres=Dialog.getNumber(); 	// area threshold. discard ROIs with pixel areas below this value.
					
					// Create new directories to store results.
					dir = getDirectory("image");
					//check if prefiltered
					print("Creating directory for filtered images");
					if(!endsWith(dir, "filter" + File.separator))
						filDir = dir + "filter" + File.separator;
					else
						filDir = dir;
					//get number of rounds and channels
					rnd = numRound(dir);
					chan = channels(dir);
					img = getTitle();

					//threshold image
					//gaussian
					thresh = histPercentile(img, 0.999);
			
					//threshold the image
					setThreshold(thresh, 255);
					setOption("BlackBackground", true);
					run("Create Mask");
					run("From ROI Manager");
					roiManager("Select", 0);
					run("Analyze Particles...", "  circularity=0.00-0.50 display clear add");

					// Delete small areas
					run("Clear Results");
					totRois = roiManager("count");
					run("Set Measurements...", "area redirect=None decimal=3");
					for (mm=totRois-1;mm>-0.5;mm--){
						roiManager("Select",mm);
						run("Measure");
						totArea=getResult("Area");
						if(totArea<areaThres){
							roiManager("Delete");
							roiManager("Update");
						}
					}
					//Save BV ROIs
					roiManager("Save", tabDir + "BVRoiSet.zip");
					close();

					//open all channel images and set pixel value in mask to 0
					dChan = newArray(1);
					dChan[0] = 405;
					dChan = Array.concat(dChan,chan);
					j = 1;
					k = 0;
					totRois = roiManager("count");
					
					//open, overlay mask, replace pixels
					for (i = 0; i < (rnd*(dChan)); i++) {
						pref = "R" + j + "_" + dChan[k];
						autoOpen(dir, pref);
						name = getTitle();
						//set pixels to be black
						for (f = 1; f <= totRois; f++) {
							roiManager("Select",f);
							roiManager("Set Fill Color", "black");
							roiManager("Show All");
						}
						saveAs("Tiff", filDir + name + "filter.tif");
						close();
					}

					// Close down all unnecessary windows.
					// Note ROIs are left behind for use by other downstream macros
					run("Close All");
					close("Results");
					close("Threshold");
					exit("Blood vessel filtering complete!");

				}

			}
					
		}
					
	}
	
}
